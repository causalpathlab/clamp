# Error Log - 2026-01-15

## Testing clamp_binary() with Binary Treatments

### Test Script
`test_clamp_binary_example.R`

---

## Error Encountered

```
Error in names(s$pip) <- variable_names :
  'names' attribute [10] must be the same length as the vector [2]
Calls: clamp_binary
Execution halted
```

**Location:** `/Users/yuanming/Dropbox/paper-causal.susie/codes/clamp/R/clamp_binary.R:500`

---

## Root Cause Analysis

### The Problem

The `clamp_get_pip()` function returns a **list** with two elements, not a vector:
```r
list(level_pip = level_pip, variable_pip = variable_pip)
```

But the code tries to assign 10 names to this list of length 2:
```r
names(s$pip) <- variable_names  # variable_names has length 10, s$pip has length 2
```

### Why This Happens

The `clamp_get_pip()` function (in `clamp_utils.R:397-438`) is designed for **categorical data** where:
- Variables can have multiple levels (e.g., `X1_0`, `X1_1`, `X1_2`)
- It returns both:
  - `level_pip`: PIP for each level (e.g., PIP for X1_1, X1_2, etc.)
  - `variable_pip`: PIP aggregated per variable (e.g., PIP for X1 overall)

For **binary data**:
- Each variable only has one "level" (0 or 1)
- Column names are just `"X1"`, `"X2"`, etc. (not `"X1_0"`, `"X1_1"`)
- The function `sub("_.*", "", colnames(res$alpha))` at line 417 tries to extract variable names by removing everything after "_", but there are no underscores in binary column names
- Since there's no "_" in the names, `variable_names` equals `level_names`, causing the aggregation logic to produce unexpected results

### Code Flow

1. **Line 416-417** in `clamp_utils.R`:
   ```r
   level_names <- colnames(res$alpha)        # ["X1", "X2", ..., "X10"]
   variable_names <- sub("_.*", "", colnames(res$alpha))  # ["X1", "X2", ..., "X10"]
   ```

2. **Line 425-426**:
   ```r
   level_pip <- as.vector(1 - apply(1 - res,2,prod))  # Length 10
   names(level_pip) <- level_names                     # ["X1", "X2", ..., "X10"]
   ```

3. **Line 428-429**:
   ```r
   variable_pip <- tapply(level_pip, variable_names,
                          function(x) {1 - prod(1-x)})  # Length 10
   ```

   Since `variable_names` equals `level_names`, `tapply` groups each element by itself, resulting in `variable_pip` also having length 10.

4. **Line 433**:
   ```r
   return(list(level_pip = level_pip, variable_pip = variable_pip))
   ```
   Returns a list of length 2, not a vector.

5. **Line 500** in `clamp_binary.R`:
   ```r
   names(s$pip) <- variable_names  # Tries to assign 10 names to list of length 2
   ```
   **ERROR**: Length mismatch.

---

## Architectural Issue

The core issue is that `clamp_binary.R` and `clamp_get_pip()` were designed with different assumptions:

- **clamp_binary.R** assumes binary data with simple variable names (`X1`, `X2`, etc.)
- **clamp_get_pip()** assumes categorical data with level-encoded names (`X1_0`, `X1_1`, `X1_2`, etc.)

The function returns a structure appropriate for categorical data (with both level-wise and variable-wise PIPs), but binary data only needs a single PIP per variable.

---

## Potential Solutions

### Solution 1: Modify clamp_binary.R to handle list output
```r
# After calling clamp_get_pip
if (is.list(s$pip)) {
  # For binary data, level_pip and variable_pip should be identical
  s$pip <- s$pip$variable_pip
}
names(s$pip) <- variable_names
```

### Solution 2: Create a separate binary-specific PIP function
Create `clamp_get_pip_binary()` that returns a simple vector instead of a list:
```r
clamp_get_pip_binary = function(res, prune_by_cs = FALSE, prior_tol = 1e-9) {
  # ... similar logic but returns just a vector
  pip <- as.vector(1 - apply(1 - res$alpha, 2, prod))
  names(pip) <- colnames(res$alpha)
  return(pip)
}
```

### Solution 3: Make clamp_get_pip() detect binary vs categorical
Modify `clamp_get_pip()` to check if column names contain underscores and return different structures accordingly.

---

## Test Context

The test was attempting to:
1. Generate 1000 samples with 10 binary treatments
2. Create confounding via 1-dim confounder Z ~ N(0,1)
3. Set true causal treatments as X3 and X7
4. Use IPW to adjust for confounding
5. Run `clamp_binary()` to identify causal variables

The algorithm successfully:
- Completed 4 iterations
- Computed objective (ELBO)
- Converged (objective improved from -2074 to -1968)

The algorithm failed when:
- Attempting to compute posterior inclusion probabilities (PIPs)
- Trying to assign names to the PIP output

---

## Status

**Not Resolved** - Needs architectural decision on how to handle binary vs categorical data in the PIP computation.

## Next Steps

1. Decide on solution approach (1, 2, or 3 above)
2. Implement the fix
3. Re-run test to verify
4. Check if similar issues exist in other utility functions

---

## Code Audit: `level_pip` and `variable_pip` Usage

### Where Defined

**R/clamp_utils.R:425-433** - Both variables are computed and returned:

```r
level_pip <- as.vector(1 - apply(1 - res,2,prod))
names(level_pip) <- level_names

variable_pip <- tapply(level_pip, variable_names,
                       function(x) {1 - prod(1-x)})
variable_pip <- variable_pip[
  order( as.numeric(sub("X", "", names(variable_pip))) )]

return(list(level_pip = level_pip, variable_pip = variable_pip))
```

### Where Used

#### 1. **R/clamp_utils.R:368** [checked]
Uses `level_pip` to find max PIP index per credible set:]
```r
max_pip_idx = sapply(res$sets$cs, function(cs) cs[which.max(res$level_pip[cs])])
```

#### 2. **R/clamp_summarize_coefficients.R:54-101** [checked]
Both variables are extensively used:
- **Line 54**: Checks if `level_pip` exists
  ```r
  if (is.null(object$level_pip) || is.null(object$mu) || is.null(object$mu2))
  ```
- **Lines 58-63**: Extracts names from `level_pip`
  ```r
  if (is.null(names(object$level_pip))) {
    level_names <- 1:length(object$level_pip)
    variable_names <- 1:length(object$variable_pip)
  } else {
    level_names <- names(object$level_pip)
    variable_names <- sapply(strsplit(names(object$level_pip), "_"), `[`, 1)
  }
  ```
- **Lines 69, 72**: Creates output dataframe with both PIPs
  ```r
  level_pip = object$level_pip,
  ...
  variable_pip = object$variable_pip[variable_names]
  ```
- **Lines 86-87**: Used for sorting output
  ```r
  output <- output[order( output$level_pip,
                          output$variable_pip,
  ```
- **Lines 99-101**: Used to calculate output dimensions
  ```r
  num_variables_output <- min(top_n, length(object$variable_pip))
  num_levels_output <- num_variables_output *
    ( length(object$level_pip) %/% length(object$variable_pip) )
  ```

#### 3. **R/summary.clamp.R:26-52**
Uses `variable_pip` for summary display:
- **Lines 26-35**: Creates variables dataframe
  ```r
  if (!is.null(names(object$variable_pip))) {
    variables = data.frame(cbind(1:length(object$variable_pip),
                                 names(object$variable_pip),
                                 object$variable_pip,
                                 -1))
  } else {
    variables = data.frame(cbind(1:length(object$variable_pip),
                                 1:length(object$variable_pip),
                                 object$variable_pip,
                                 -1))
  }
  ```
- **Lines 50-52**: Uses names from `variable_pip` for credible set display
  ```r
  if (!is.null(names(object$variable_pip))) {
    cs$variable[i] =
      paste(names(object$variable_pip)[ object$sets$cs[[i]] ], collapse = ",")
  ```

### Key Observations

1. **Architectural Design**: The code expects both `level_pip` and `variable_pip` to be stored in the result object
2. **Dependencies**: Multiple downstream functions (`clamp_summarize_coefficients`, `summary.clamp`) depend on both variables being present
3. **Naming Convention**: The code assumes level names follow the pattern `variable_level` (e.g., `X1_0`, `X1_1`) to extract variable names via splitting on "_"
4. **Binary Data Issue**: For binary treatments, there's only one level per variable, causing `level_pip` and `variable_pip` to be identical, but the current code structure still expects both
